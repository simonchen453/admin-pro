package com.adminpro.core.jdbc;

import com.adminpro.core.base.context.AppContext;
import com.adminpro.core.base.entity.*;
import com.adminpro.core.base.util.CommonUtil;
import com.adminpro.core.base.util.LoggerUtil;
import com.adminpro.core.base.util.ReflectUtil;
import com.adminpro.core.exceptions.BaseRuntimeException;
import com.adminpro.core.exceptions.DBException;
import com.adminpro.core.jdbc.annotation.AutoGeneratedKey;
import com.adminpro.core.jdbc.annotation.PrimaryKey;
import com.adminpro.core.jdbc.annotation.Table;
import com.adminpro.core.jdbc.annotation.Column;
import com.adminpro.core.jdbc.query.QueryResultSet;
import com.adminpro.core.jdbc.sqlbuilder.*;
import com.adminpro.core.jdbc.utils.ClassUtil;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.*;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;


import javax.sql.DataSource;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.math.BigDecimal;
import java.sql.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

public abstract class SqlExecutor<E extends IEntity, ID extends Serializable> implements Serializable {

    private static final long serialVersionUID = 2872372126946775131L;

    private static final Logger showSqlLogger = LoggerFactory.getLogger("com.adminpro.sql");

    private static final Logger logger = LoggerFactory.getLogger(SqlExecutor.class);

    @Value("${app.jdbc.show.sql:false}")
    private boolean showSql;
    private Class<E> genericType;
    protected JdbcTemplate jdbcTemplate;
    protected NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    public SqlExecutor() {
        genericType = (Class<E>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    }

    @Autowired
    public void setDataSource(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
        namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }

    protected long execute(InsertBuilder insert) {
        if (showSql) {
            String sql = insert.getSql();
            Object[] paramValues = insert.getParamValues();
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (paramValues != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(paramValues));
            }
        }

        return jdbcTemplate.update(insert.getSql(), insert.getParamValues());
    }

    protected int execute(UpdateBuilder update) {
        return update(update.getSql(), update.getParamValues());
    }

    protected int execute(DeleteBuilder delete) {
        return update(delete.getSql(), delete.getParamValues());
    }

    protected <T> List<T> execute(SelectBuilder<T> select) {
        try {
            List<Object> whereValues = select.getWhereValues();
            Map<String, Object> whereValuesMap = select.getWhereValuesMap();
            if (whereValuesMap != null && whereValuesMap.size() > 0) {
                return query(select.getSql(), whereValuesMap, select.getRowMapper());
            } else {
                Object[] objs = null;
                if (whereValues != null) {
                    objs = whereValues.toArray();
                }
                return query(select.getSql(), objs, select.getRowMapper());
            }
        } catch (Exception e) {
            throw new DBException(e);
        }
    }

    protected <T> T executeSingle(SelectBuilder<T> select) {
        List<T> results = execute(select);
        if (results != null && !results.isEmpty()) {
            return results.get(0);
        }
        return null;
    }

    protected <T> QueryResultSet<T> search(SelectBuilder<T> select) throws BaseRuntimeException {
        List<Object> whereValues = select.getWhereValues();
        Map<String, Object> whereValuesMap = select.getWhereValuesMap();
        List<T> rows = null;
        int rowCount = 0;

        if (whereValuesMap != null && whereValuesMap.size() > 0) {
            rows = query(select.getSql(), select.getWhereValuesMap(), select.getRowMapper());

            if (select.getPageSize() > 0 && select.getPageNo() > 0) {
                rowCount = queryForInt(select.getCountSql(), whereValuesMap);
            } else if (rows != null) {
                rowCount = rows.size();
            }

        } else {
            Object[] objs = null;
            if (whereValues != null) {
                objs = whereValues.toArray();
            }
            rows = query(select.getSql(), objs, select.getRowMapper());

            if (select.getPageSize() > 0 && select.getPageNo() > 0) {
                rowCount = queryForInt(select.getCountSql(), objs);
            } else if (rows != null) {
                rowCount = rows.size();
            }
        }
        QueryResultSet<T> resultSet = new QueryResultSet<>();
        resultSet.setRecords(rows);
        resultSet.setCurrentPage(select.getPageNo());
        resultSet.setPageSize(select.getPageSize());
        resultSet.setTotalCount(rowCount);

        if (rowCount == 0) {
            resultSet.setTotalPage(0);
        } else {
            resultSet.setTotalPage((int) Math.ceil((double) rowCount / (double) select.getPageSize()));
        }

        return resultSet;
    }

    public Integer executeSQL(String sql, Object... objs) {
        return jdbcTemplate.update(sql, objs);
    }

    protected int update(String sql, Object... args) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (args != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(args));
            }
        }

        return jdbcTemplate.update(sql, args);
    }

    protected <T> List<T> query(String sql, Object[] args, RowMapper<T> rowMapper) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (args != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(args));
            }
        }

        return jdbcTemplate.query(sql, rowMapper, args);
    }

    protected <T> List<T> queryNamedParameter(SelectBuilder<T> builder) {
        return query(builder.getSql(), builder.getWhereValuesMap(), builder.getRowMapper());
    }

    protected <T> List<T> query(String sql, Map<String, Object> args, RowMapper<T> rowMapper) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (args != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(args));
            }
        }

        return namedParameterJdbcTemplate.query(sql, args, rowMapper);
    }

    protected <T> T queryForObject(String sql, Map<String, Object> args, RowMapper<T> rowMapper) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (args != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(args));
            }
        }

        try {
            return namedParameterJdbcTemplate.queryForObject(sql, args, rowMapper);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

    protected <T> T queryForObject(String sql, Object[] args, RowMapper<T> rowMapper) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (args != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(args));
            }
        }

        try {
            T t = jdbcTemplate.queryForObject(sql, rowMapper, args);
            return t;
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

    protected int[] batchUpdate(InsertBuilder insert) {
        return batchUpdate(insert.getSql(), insert.getValues());
    }

    protected int[] batchUpdate(UpdateBuilder update) {
        return batchUpdate(update.getSql(), update.getValues());
    }

    protected int[] batchUpdate(String sql, final List<Object> args) {
        if (showSqlLogger.isDebugEnabled()) {
            showSqlLogger.debug(formatLogging(sql, null));
        }
        return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                Object[] params = (Object[]) args.get(i);
                if (params != null) {
                    for (int j = 1; j <= params.length; j++) {
                        Object param = params[j - 1];
                        if (param == null) {
                            ps.setNull(j, Types.NULL);
                            continue;
                        }
                        if (param instanceof String) {
                            ps.setString(j, (String) param);
                        } else if (param instanceof Integer) {
                            ps.setInt(j, (Integer) param);
                        } else if (param instanceof Long) {
                            ps.setLong(j, (Long) param);
                        } else if (param instanceof Double) {
                            ps.setDouble(j, (Double) param);
                        } else if (param instanceof Date) {
                            ps.setTimestamp(j, new Timestamp(((Date) param).getTime()));
                        } else if (param instanceof BigDecimal) {
                            ps.setBigDecimal(j, (BigDecimal) param);
                        }
                    }
                }
            }

            @Override
            public int getBatchSize() {
                return args.size();
            }
        });
    }

    public int queryForInt(String sql, Object[] args) {
        Number number = queryForObject(sql, args, new RowMapper<Integer>() {
            private static final long serialVersionUID = -1441805729141311583L;

            @Override
            public Integer mapRow(ResultSet rs, int rowNum) throws SQLException {
                return Integer.valueOf(rs.getInt(1));
            }
        });
        return ((number != null) ? number.intValue() : 0);
    }

    public int queryForInt(String sql, Map<String, Object> map) {
        if (showSql) {
            showSqlLogger.debug("SQL Statement: " + sql.toUpperCase());
            if (map != null) {
                showSqlLogger.debug("SQL Parameter: " + LoggerUtil.buildMessage(map));
            }
        }

        Number number = queryForObject(sql, map, new RowMapper<Integer>() {
            private static final long serialVersionUID = -1441805729141311583L;

            @Override
            public Integer mapRow(ResultSet rs, int rowNum) throws SQLException {
                return Integer.valueOf(rs.getInt(1));
            }
        });
        return ((number != null) ? number.intValue() : 0);
    }

    protected void handleAuditColumnValues(InsertBuilder insert, IEntity entity) {
        if (entity instanceof BaseAuditEntity) {
            BaseAuditEntity obj = (BaseAuditEntity) entity;
            AppContext appContext = CommonUtil.getAppContext();
            String userId = "";
            String userDomain = "";
            if (appContext != null) {
                userId = appContext.getUserId();
                userDomain = appContext.getUserDomain();
            }
            Date now = new Date();
            if (obj.getCreatedDate() == null) {
                obj.setCreatedDate(now);
                insert.addColumnValue(BaseAuditEntity.COL_CREATED_DATE, now);
            }

            if (StringUtils.isEmpty(obj.getCreatedByUserId())) {
                obj.setCreatedByUserId(userId);
                insert.addColumnValue(BaseAuditEntity.COL_CREATED_BY_USER_ID, obj.getCreatedByUserId());
            }
            if (StringUtils.isEmpty(obj.getCreatedByUserDomain())) {
                obj.setCreatedByUserDomain(userDomain);
                insert.addColumnValue(BaseAuditEntity.COL_CREATED_BY_USER_DOMAIN, obj.getCreatedByUserDomain());
            }

            if (obj.getUpdatedDate() == null) {
                obj.setUpdatedDate(now);
                insert.addColumnValue(BaseAuditEntity.COL_UPDATED_DATE, now);
            }

            if (StringUtils.isEmpty(obj.getUpdatedByUserId())) {
                obj.setUpdatedByUserId(userId);
                insert.addColumnValue(BaseAuditEntity.COL_UPDATED_BY_USER_ID, obj.getUpdatedByUserId());
            }
            if (StringUtils.isEmpty(obj.getUpdatedByUserDomain())) {
                obj.setUpdatedByUserDomain(userDomain);
                insert.addColumnValue(BaseAuditEntity.COL_UPDATED_BY_USER_DOMAIN, obj.getUpdatedByUserDomain());
            }
        }
    }

    protected void handleAuditColumnValues(UpdateBuilder update, IEntity entity) {
        if (entity instanceof BaseAuditEntity) {
            AppContext appContext = CommonUtil.getAppContext();
            String userId = "";
            String userDomain = "";
            if (appContext != null) {
                userId = appContext.getUserId();
                userDomain = appContext.getUserDomain();
            }

            BaseAuditEntity obj = (BaseAuditEntity) entity;
            Date now = new Date();

            obj.setUpdatedDate(now);
            update.addColumnValue(BaseAuditEntity.COL_UPDATED_DATE, now);

            if (StringUtils.isEmpty(obj.getCreatedByUserId())) {
                obj.setUpdatedByUserId(userId);
                update.addColumnValue(BaseAuditEntity.COL_UPDATED_BY_USER_ID, obj.getUpdatedByUserId());
            }

            if (StringUtils.isEmpty(obj.getCreatedByUserDomain())) {
                obj.setUpdatedByUserDomain(userDomain);
                update.addColumnValue(BaseAuditEntity.COL_UPDATED_BY_USER_DOMAIN, obj.getUpdatedByUserDomain());
            }
        }
    }

    protected void retrieveAuditField(BaseEntity entity, ResultSet resultSet) {
        if (entity instanceof BaseAuditEntity) {
            BaseAuditEntity auditEntity = (BaseAuditEntity) entity;
            try {
                auditEntity.setCreatedByUserDomain(resultSet.getString(BaseAuditEntity.COL_CREATED_BY_USER_DOMAIN));
                auditEntity.setCreatedByUserId(resultSet.getString(BaseAuditEntity.COL_CREATED_BY_USER_ID));
                auditEntity.setUpdatedByUserDomain(resultSet.getString(BaseAuditEntity.COL_UPDATED_BY_USER_DOMAIN));
                auditEntity.setUpdatedByUserId(resultSet.getString(BaseAuditEntity.COL_UPDATED_BY_USER_ID));
                auditEntity.setCreatedDate(resultSet.getTimestamp(BaseAuditEntity.COL_CREATED_DATE));
                auditEntity.setUpdatedDate(resultSet.getTimestamp(BaseAuditEntity.COL_UPDATED_DATE));
            } catch (SQLException e) {
                logger.error("Failed to retrieve audit field from ResultSet", e);
            }
        }
    }

    protected void retrieveAuditField(BaseDTO entity, ResultSet resultSet) {
        if (entity instanceof BaseAuditDTO) {
            BaseAuditDTO auditEntity = (BaseAuditDTO) entity;
            try {
                auditEntity.setCreatedByUserDomain(resultSet.getString(BaseAuditEntity.COL_CREATED_BY_USER_DOMAIN));
                auditEntity.setCreatedByUserId(resultSet.getString(BaseAuditEntity.COL_CREATED_BY_USER_ID));
                auditEntity.setUpdatedByUserDomain(resultSet.getString(BaseAuditEntity.COL_UPDATED_BY_USER_DOMAIN));
                auditEntity.setUpdatedByUserId(resultSet.getString(BaseAuditEntity.COL_UPDATED_BY_USER_ID));
                auditEntity.setCreatedDate(resultSet.getTimestamp(BaseAuditEntity.COL_CREATED_DATE));
                auditEntity.setUpdatedDate(resultSet.getTimestamp(BaseAuditEntity.COL_UPDATED_DATE));
            } catch (SQLException e) {
                logger.error("Failed to retrieve audit field from ResultSet", e);
            }
        }
    }

    public void create(final E entity) {
        if(entity == null){
            throw new IllegalArgumentException(String.format("entity cannot be null."));
        }
        Table tbl = genericType.getAnnotation(Table.class);
        if (tbl == null) {
            throw new IllegalArgumentException(String.format("Table is not specified for entity %s.", genericType.getClass()));
        }

        InsertBuilder insert = new InsertBuilder(tbl.name());
        Field[] fields = ClassUtil.getAllFields(genericType);
        List<Field> autoGenFields = new ArrayList<>(5);
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(Column.class)) {
                    Column col = field.getAnnotation(Column.class);
                    if (col != null) {
                        field.setAccessible(true);
                        Object value = null;
                        try {
                            value = field.get(entity);
                        } catch (IllegalAccessException ex) {
                            throw new BaseRuntimeException("Failed to get field value.", ex);
                        }
                        if (field.isAnnotationPresent(AutoGeneratedKey.class)) {
                            if (value == null || StringUtils.isBlank(value.toString()) || "0".equals(String.valueOf(value))) {
                                autoGenFields.add(field);
                                if (field.isAnnotationPresent(PrimaryKey.class)) {
                                    insert.setAutoGeneratedType(field.getType().getName());
                                    insert.setAutoGeneratedKey(col.name());
                                }
                            } else {
                                insert.addColumnValue(col.name(), value);
                            }
                        } else {
                            if (value != null) {
                                String fieldName = col.field();
                                if (StringUtils.isBlank(fieldName)) {
                                    insert.addColumnValue(col.name(), value);
                                } else {
                                    // the field data of child object
                                    Object val = ReflectUtil.getFieldValue(value, fieldName);
                                    insert.addColumnValue(col.name(), val);
                                }
                            }
                        }
                    }
                }
            }
        }
        handleAuditColumnValues(insert, entity);
        execute(insert);
        if (StringUtils.isNotBlank(insert.getAutoGeneratedKey())) {
            try {
                if (CollectionUtils.isNotEmpty(autoGenFields)) {
                    if (autoGenFields.size() > 1) {
                        String[] cols = new String[autoGenFields.size()];
                        for (int i = 0; i < autoGenFields.size(); i++) {
                            cols[i] = autoGenFields.get(i).getName();
                        }
                        String sql = String.format("SELECT %s FROM %s WHERE %s = ?", StringUtils.join(cols), entity.getClass().getDeclaredField("TABLE_NAME").get(null), insert.getAutoGeneratedKey());
                        com.adminpro.core.jdbc.Column[] keys = queryForObject(sql, new Object[]{insert.getAutoGeneratedValue()}, new RowMapper<com.adminpro.core.jdbc.Column[]>() {
                            @Override
                            public com.adminpro.core.jdbc.Column[] mapRow(ResultSet rs, int rowNum) throws SQLException {
                                com.adminpro.core.jdbc.Column[] vals = new com.adminpro.core.jdbc.Column[autoGenFields.size()];
                                for (int i = 0; i < autoGenFields.size(); i++) {
                                    Field autoGenField = autoGenFields.get(i);
                                    vals[i] = new com.adminpro.core.jdbc.Column(autoGenField.getName(), autoGenField.getType().getName(), rs.getObject(autoGenField.getName()));
                                }
                                return vals;
                            }
                        });
                        for (Field autoGenField : autoGenFields) {
                            String fieldName = autoGenField.getName();
                            for (com.adminpro.core.jdbc.Column key : keys) {
                                if (fieldName.equals(key.getName())) {
                                    setAutoGeneratedFieldValue(autoGenField, entity, key.getValue());
                                }
                            }
                        }
                    } else {
                        setAutoGeneratedFieldValue(autoGenFields.get(0), entity, insert.getAutoGeneratedValue());
                    }
                }
            } catch (Exception ex) {
                throw new BaseRuntimeException("Failed to get the auto increase field value.", ex);
            }
        }
    }

    private void setAutoGeneratedFieldValue(Field autoGenField, Object entity, Object value) throws IllegalAccessException {
        String autoGenFieldType = autoGenField.getType().getName();
        if ("long".equals(autoGenFieldType)) {
            autoGenField.set(entity, Long.valueOf(value.toString()));
        } else if ("int".equals(autoGenFieldType)) {
            autoGenField.set(entity, Integer.valueOf(value.toString()));
        } else if ("java.lang.String".equals(autoGenFieldType)) {
            autoGenField.set(entity, value);
        } else {
            throw new IllegalAccessException("The type of auto generated key is not supported yet.");
        }
    }

    private void setWhereClause(WhereClause where, String column, String type, Object value) {
        if ("long".equals(type)) {
            where.setWhereClause(column + " = ?", Long.valueOf(value.toString()));
        } else if ("int".equals(type)) {
            where.setWhereClause(column + " = ?", Integer.valueOf(value.toString()));
        } else {
            where.setWhereClause(column + " = ?", (String) value);
        }
    }

    private DBRowMapper<E> getDefaultRowMapper() {
        return new DBRowMapper<>(genericType);
    }

    public E retrieve(final ID id) {
        Table tbl = genericType.getAnnotation(Table.class);
        if (tbl == null) {
            throw new IllegalArgumentException(String.format("Table is not specified for entity %s.", genericType.getClass()));
        }

        SelectBuilder<E> select = new SelectBuilder<>(getDefaultRowMapper());
        Field[] fields = ClassUtil.getAllFields(genericType);
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(PrimaryKey.class)) {
                    Column col = field.getAnnotation(Column.class);
                    if (col != null) {
                        String fieldType = field.getType().getName();
                        setWhereClause(select, col.name(), fieldType, id);
                        break;
                    }
                }
            }
        }
        return executeSingle(select);
    }

    public List<E> retrieveAll() {
        Table tbl = genericType.getAnnotation(Table.class);
        if (tbl == null) {
            throw new IllegalArgumentException(String.format("Table is not specified for entity %s.", genericType.getClass()));
        }

        SelectBuilder<E> select = new SelectBuilder<>(getDefaultRowMapper());
        return execute(select);
    }

    public void delete(final ID id) {
        Table tbl = genericType.getAnnotation(Table.class);
        if (tbl == null) {
            throw new IllegalArgumentException(String.format("Table is not specified for entity %s.", genericType.getClass()));
        }

        DeleteBuilder delete = new DeleteBuilder(tbl.name());
        Field[] fields = ClassUtil.getAllFields(genericType);
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(PrimaryKey.class)) {
                    Column col = field.getAnnotation(Column.class);
                    if (col != null) {
                        String fieldType = field.getType().getName();
                        setWhereClause(delete, col.name(), fieldType, id);
                        break;
                    }
                }
            }
        }
        execute(delete);
    }

    public void update(final E entity, String... columns) {
        if(entity == null){
            throw new IllegalArgumentException(String.format("entity cannot be null."));
        }
        Table tbl = genericType.getAnnotation(Table.class);
        if (tbl == null) {
            throw new IllegalArgumentException(String.format("Table is not specified for entity %s.", genericType.getClass()));
        }

        Field[] fields = null;
        if (columns != null && columns.length > 0) {
            List<Field> tmpFlds = new ArrayList<>();
            Field[] allFields = ClassUtil.getAllFields(genericType);
            for (Field field : allFields) {
                Column col = field.getAnnotation(Column.class);
                for (String column : columns) {
                    if (col != null && column.equals(col.name())) {
                        tmpFlds.add(field);
                        break;
                    }
                }
            }
            fields = tmpFlds.toArray(new Field[tmpFlds.size()]);
        }
        UpdateBuilder update = new UpdateBuilder(tbl.name());
        if (fields == null || fields.length == 0) {
            //full table update
            fields = ClassUtil.getAllFields(genericType);
        }
        if (fields != null && fields.length > 0) {
            for (Field field : fields) {
                if (field.isAnnotationPresent(Column.class)) {
                    Column col = field.getAnnotation(Column.class);
                    if (col != null) {
                        field.setAccessible(true);
                        try {
                            if (field.isAnnotationPresent(PrimaryKey.class)) {
                                update.setWhereClause(col.name() + " = ?", field.get(entity));
                            } else {
                                String colField = col.field();
                                if (StringUtils.isNotBlank(colField) && field.get(entity) != null) {
                                    update.addColumnValue(col.name(), ReflectUtil.getFieldValue(field.get(entity), colField));
                                } else {
                                    update.addColumnValue(col.name(), field.get(entity));
                                }
                            }
                        } catch (IllegalAccessException ex) {
                            throw new BaseRuntimeException("Failed to get the field value.", ex);
                        }
                    }
                }
            }
        }
        if (StringUtils.isBlank(update.getWhere())) {
            Field[] allFields = ClassUtil.getAllFields(genericType);
            if (allFields != null && allFields.length > 0) {
                try {
                    for (Field field : allFields) {
                        if (field.isAnnotationPresent(PrimaryKey.class)) {
                            Column col = field.getAnnotation(Column.class);
                            if (col != null) {
                                field.setAccessible(true);
                                update.addWhereAnd(col.name() + " = ?", field.get(entity));
                            }
                        }
                    }
                } catch (IllegalAccessException ex) {
                    throw new BaseRuntimeException("Failed to get the field value.", ex);
                }
            }
        }
        handleAuditColumnValues(update, entity);
        execute(update);
    }

    private String formatLogging(String sql, Object[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("SQL = ").append(sql);
        if (args != null && args.length > 0) {
            sb.append(", PARAMS = {");
            for (int i = 0; i < args.length; i++) {
                sb.append(args[i] == null ? null : args[i].toString());
                if (i < args.length - 1) {
                    sb.append(", ");
                }
            }

            sb.append('}');
        }
        return sb.toString();
    }

    protected <T> int count(SelectBuilder<T> select) {
        List<Object> whereValues = select.getWhereValues();
        Object[] objs = null;
        if (whereValues != null) {
            objs = whereValues.toArray();
        }
        return queryForInt(select.getCountSql(), objs);
    }

    protected <T> T execute(CallableStatementCreator a, CallableStatementCallback<T> b) {
        return jdbcTemplate.execute(a, b);
    }
}
